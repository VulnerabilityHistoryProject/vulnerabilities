CVE: CVE-2013-2635
curation_level: 2
reported_date:
published_date: '2013-03-22'
description: |
  This vulnerability was due to a miscalculation of a buffer size
  relative to the data actually allocated to that buffer. 32 bytes were
  allocated to the mac address buffer, but only 6 bytes of the buffer were
  filled. This means that 26 bytes would end up leaking, which could be accessed
  by an external application.
bounty:
  amt:
  announced:
  url:
reviews: []
bugs: [https://bugzilla.redhat.com/show_bug.cgi?id=924690]
fixes:
- commit: 84d73cd3fb142bf1298a8c13fd4ca50fd2432372
  note: Manually confirmed
vccs:
- commit: 5f8444a3fa617076f8da51a3e8ecce01a5d7f738
  note: Discovered automatically by archeogit.
- commit: ebc08a6f47ee76ecad8e9f26c26e6ec9b46ca659
  note: Discovered automatically by archeogit.
upvotes: 2
unit_tested:
  code: false
  code_answer:
  fix: false
  fix_answer: |
    I wasn't able to find unit tests for this module, and it doesn't look like tests were involved in finding this bug. (It appeared to be found by 
    the use of external applications)
discovered:
  answer: |
    This was found by security engineer Mathias Krause, seemingly while searching for Ubuntu data leaks.
    The Ubuntu update including this fix included a plethora of other fixes for data leaks throughout the project.
  automated: false
  contest: false
  developer: false
autodiscoverable:
  note: | 
    It was stated that the data leak caused by this vulnerability could be found via a crafted application, 
    meaning that the application would need to be aware of specific project elements to find leaks.
  answer: true
specification:
  note:
  answer: false
subsystem:
  name: netlink
  note: Reports and file directories all point toward the bug being contained to the netlink subsystem.
    
interesting_commits:
  question: |
    Are there any interesting commits between your VCC(s) and fix(es)?

    Use this to specify any commits you think are notable in some way, and
    explain why in the note.

    Example interesting commits:
      * Mentioned as a problematic commit in the past
        e.g. "This fixes regression in commit xys"
      * A significant rewrite in the git history
      * Other commits that fixed a similar issue as this vulnerability
      * Anything else you find interesting.
  commits:
  - commit: c085c49920b2f900ba716b4ca1c1a55ece9872cc
    note: | 
      This is another data leak in the netlink interface that was fixed around the same time. 
      The fix used in both cases was initializing unset values with memset(0), so this appeared to be a widespread bug with a similar fix.
i18n:
  answer: false
  note: This vulnerability is unrelated to i18n, as it strictly relates to buffer memory allocation.
sandbox:
  answer: false
  note: This vulnerability does not involve permissions or file access.
ipc:
  answer: false
  note: There is not inter-process communication involved, as the memory allocation is just for the Linux kernel.
discussion:
  discussed_as_security: false
  any_discussion: false 
  note: I wasn't able to find any discussion, it looks like the bug was found along with other memory leaks and quickly fixed.
vouch:
  answer: false
  note: |
    David S. Miller (davem@davemloft.net) and Mathias Krause (minipli@googlemail.com) signed off on the commit. 
    Mathias Krause was also the author of the commit.
stacktrace:
  any_stacktraces: true
  stacktrace_with_fix: true
  note: The vulnerability was sourced to the rtnl_fill_ifinfo function in net/core/rtnetlink.c in the Linux kernel.
forgotten_check:
  answer: false
  note: The vulnerability was not due to a forgotten check, but rather a misunderstanding of the size of data.
order_of_operations:
  answer: false
  note: No, the fix involved changing how memory was specifically allocated. This was a simple change in the set value, rather than the order of anything.
lessons:
  defense_in_depth:
    applies: false
    note:
  least_privilege:
    applies: false
    note:
  frameworks_are_optional:
    applies: false
    note:
  native_wrappers:
    applies: false
    note:
  distrust_input:
    applies: false
    note:
  security_by_obscurity:
    applies: false
    note:
  serial_killer:
    applies: false
    note:
  environment_variables:
    applies: true
    note: |
      A misunderstanding of the size of a system variable filling the buffer led to this vulnerability.
      A greater awareness of the system and more careful memory allocation could have prevented this.
  secure_by_default:
    applies: false
    note:
  yagni:
    applies: false
    note:
  complex_inputs:
    applies: false
    note:
mistakes:
  answer: |
    This vulnerability was caused by a simple misunderstanding in the size of the data being used to fill a buffer. 
    More memory was allocated than was ultimately used by the MAC address being placed there, meaning that the remaining memory was vulnerable to leaking. 
    The fix looks proper based on my understanding of the issue, as it was used universally for identical memory leaks in the same project. 
    Memset is used to initialize unset members and pad bytes, preventing the remaining memory from leaking. For future reference,  
    it is important to verify the size of data you are using when you allocate space for it, as any improper allocation could lead to errors or leaks.
CWE: "131"
CWE_note:
nickname: RTNetlink Unfilled Buffer Leak
CVSS: 
