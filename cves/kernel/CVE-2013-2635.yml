CVE: CVE-2013-2635
curation_level: 2
reported_date: '2013-03-10'
announced_date: '2013-03-22'
published_date: '2013-03-22'
description: |
  This vulnerability was due to a miscalculation of a buffer size
  relative to the data actually allocated to that buffer. 32 bytes were
  allocated to the mac address buffer, but only 6 bytes of the buffer were
  filled. This means that 26 bytes would end up leaking, which could be accessed
  by an external application.
bounty:
  amt:
  announced:
  url:
reviews: []
bugs: ["https://bugzilla.redhat.com/show_bug.cgi?id=924690"]
fixes:
- commit: 84d73cd3fb142bf1298a8c13fd4ca50fd2432372
  note: Manually confirmed
vccs:
- commit: 5f8444a3fa617076f8da51a3e8ecce01a5d7f738
  note: Manually confirmed
- commit: ebc08a6f47ee76ecad8e9f26c26e6ec9b46ca659
  note: Manually confirmed
upvotes: 2
unit_tested:
  code: false
  code_answer: false
  fix: false
  fix_answer: |
    Searching through the code, no unit tests were found for this module, and it doesn't look like tests were involved in finding this bug.
    The bug was found with external applications that could collect data from leaks.
discovered:
  answer: |
    This was found by security engineer Mathias Krause while searching for Ubuntu data leaks.
    The Ubuntu update including this fix included a plethora of other fixes for data leaks throughout the project.
  automated: false
  contest: false
  developer: false
autodiscoverable:
  note: | 
    It was stated that the data leak caused by this vulnerability could be found via a crafted application, 
    meaning that the application would need to be aware of specific project elements to find leaks.
  answer: true
specification:
  note: |
    There is not a specification for this memory allocation, as it depended on the size of the data used.
    Guaranteeing that the correct buffer was created is depdendent on the situation.
  answer: false
subsystem:
  name: netlink
  note: Reports and file directories all point toward the bug being contained to the netlink subsystem.
interesting_commits:
  commits:
  - commit: c085c49920b2f900ba716b4ca1c1a55ece9872cc
    note: | 
      This is another data leak in the netlink interface that was fixed around the same time. 
      The fix used in both cases was initializing unset values with memset(0), so this appeared to be a widespread bug with a similar fix.
i18n:
  answer: false
  note: This vulnerability is unrelated to i18n, as it strictly relates to buffer memory allocation.
sandbox:
  answer: false
  note: This vulnerability does not involve permissions or file access.
ipc:
  answer: false
  note: |
    There is not inter-process communication involved, 
    as the memory allocation is just for the Linux kernel.
discussion:
  discussed_as_security: false
  any_discussion: false 
  note: |
    This bug was found along with other memory leaks and was quickly fixed,
    so there was no discussion found about causes or potential fixes.
vouch:
  answer: true
  note: |
    David S. Miller (davem@davemloft.net) and Mathias Krause (minipli@googlemail.com) signed off on the commit. 
    Mathias Krause was also the author of the commit.
stacktrace:
  any_stacktraces: true
  stacktrace_with_fix: true
  note: |
    The vulnerability was sourced to the rtnl_fill_ifinfo function in 
    net/core/rtnetlink.c in the Linux kernel.
forgotten_check:
  answer: true
  note: |
    The vulnerability was due to forgetting to check the size of the
    mac address before allocating a buffer for it in memory.
order_of_operations:
  answer: false
  note: |
    No, the fix involved changing how memory was specifically allocated. 
    This was a simple change in the set value, rather than the order of anything.
lessons:
  defense_in_depth:
    applies:
    note:
  least_privilege:
    applies:
    note:
  frameworks_are_optional:
    applies:
    note:
  native_wrappers:
    applies:
    note:
  distrust_input:
    applies:
    note:
  security_by_obscurity:
    applies:
    note:
  serial_killer:
    applies:
    note:
  environment_variables:
    applies: true
    note: |
      A misunderstanding of the size of a system variable filling the buffer led to this vulnerability.
      A greater awareness of the system and more careful memory allocation could have prevented this.
  secure_by_default:
    applies:
    note:
  yagni:
    applies:
    note:
  complex_inputs:
    applies:
    note:
mistakes:
  answer: |
    This vulnerability was caused by a simple misunderstanding in the size of the data being used to fill a buffer. This could be described as a planning error,
    as it was an oversight when writing the function about how much data was going to be needed. More memory was allocated than was ultimately used by the MAC address being placed there, 
    meaning that the remaining memory was vulnerable to leaking. The fix looks proper, as it was used universally for identical memory leaks in the same project. 
    Memset is used to initialize unset members and pad bytes, preventing the remaining memory from leaking.
CWE: '399'
CWE_note:
nickname: RTNetlink Unfilled Buffer Leak
CVSS: